<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Halloween Puzzle Game</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
body { 
    background: linear-gradient(135deg, #1a1a1a 0%, #2d1b00 100%); 
    color: #fff; 
    font-family: 'Segoe UI', sans-serif; 
    margin: 0; 
    padding: 0; 
    min-height: 100vh;
}
.container { 
    max-width: 800px; 
    margin: 40px auto; 
    background: linear-gradient(135deg, #2b2b2b 0%, #1a1a1a 100%);
    padding: 30px; 
    border-radius: 16px; 
    box-shadow: 0 8px 32px rgba(255, 140, 0, 0.3);
    border: 2px solid rgba(255, 140, 0, 0.2);
}
h1 { 
    text-align: center; 
    font-size: 2.5rem; 
    margin-bottom: 20px; 
    color: #ff8c00;
    text-shadow: 0 0 20px rgba(255, 140, 0, 0.5);
    animation: glow 2s ease-in-out infinite alternate;
}
@keyframes glow {
    from { text-shadow: 0 0 10px rgba(255, 140, 0, 0.5); }
    to { text-shadow: 0 0 25px rgba(255, 140, 0, 0.8), 0 0 35px rgba(255, 140, 0, 0.5); }
}
#progressBar { 
    background: #555; 
    border-radius: 10px; 
    overflow: hidden; 
    height: 25px; 
    margin-bottom: 20px;
    border: 2px solid #777;
}
#progressFill { 
    background: linear-gradient(90deg, #ff8c00, #ff6b00); 
    height: 100%; 
    width: 0%; 
    transition: width 0.5s ease;
    box-shadow: 0 0 10px rgba(255, 140, 0, 0.6);
}
.levelInfo {
    text-align: center;
    font-size: 1.1rem;
    color: #ffa500;
    margin-bottom: 15px;
    font-weight: bold;
}
.shuffleContainer { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 10px; 
    margin: 25px 0; 
    justify-content: center;
    min-height: 60px;
}
.shuffleChar { 
    width: 50px; 
    height: 50px; 
    background: linear-gradient(135deg, #ffb347, #ff8c00);
    color: #000; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    border-radius: 8px; 
    font-weight: bold; 
    font-size: 1.3rem;
    cursor: grab; 
    user-select: none;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s, box-shadow 0.2s;
}
.shuffleChar:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 6px 15px rgba(255, 140, 0, 0.5);
}
.shuffleChar:active {
    cursor: grabbing;
}
.answerContainer { 
    display: flex; 
    gap: 8px; 
    justify-content: center; 
    flex-wrap: wrap; 
    margin-bottom: 25px;
    min-height: 60px;
}
.answerSlot { 
    width: 50px; 
    height: 50px; 
    background: #444; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    border-radius: 8px; 
    font-weight: bold;
    font-size: 1.3rem;
    border: 2px dashed #666;
    transition: all 0.3s;
}
.answerSlot.filled {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    border: 2px solid #4CAF50;
    color: #fff;
}
.answerSlot.dragover {
    background: #666;
    border-color: #ff8c00;
    transform: scale(1.1);
}
#hint { 
    text-align: center; 
    margin-bottom: 20px; 
    color: #ffd700;
    font-size: 1.3rem;
    font-weight: 600;
    padding: 15px;
    background: rgba(255, 215, 0, 0.1);
    border-radius: 10px;
    border: 1px solid rgba(255, 215, 0, 0.3);
}
#timer { 
    text-align: center; 
    margin-bottom: 25px;
    font-size: 1.4rem;
    font-weight: bold;
    color: #ff6b6b;
    text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
}
#rewardBtn { 
    display: none; 
    margin: 20px auto; 
    padding: 15px 40px; 
    background: linear-gradient(135deg, #ff8c00, #ff6b00);
    color: #000; 
    font-weight: bold; 
    border: none; 
    border-radius: 10px; 
    cursor: pointer; 
    font-size: 1.4rem;
    box-shadow: 0 4px 15px rgba(255, 140, 0, 0.4);
    transition: all 0.3s;
}
#rewardBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(255, 140, 0, 0.6);
}
#rewardBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.message {
    text-align: center;
    padding: 15px;
    margin: 20px 0;
    border-radius: 10px;
    font-weight: 600;
}
.message.success {
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    border: 1px solid #4CAF50;
}
.message.error {
    background: rgba(244, 67, 54, 0.2);
    color: #f44336;
    border: 1px solid #f44336;
}
.message.info {
    background: rgba(33, 150, 243, 0.2);
    color: #2196F3;
    border: 1px solid #2196F3;
}
.controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 20px;
}
.btn {
    padding: 10px 20px;
    border-radius: 8px;
    border: none;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
}
.btn-secondary {
    background: #555;
    color: #fff;
}
.btn-secondary:hover {
    background: #666;
}
</style>
</head>
<body>

<div class="container">
    <h1>üéÉ Halloween Puzzle Game</h1>
    <div id="progressBar"><div id="progressFill"></div></div>
    <div class="levelInfo" id="levelInfo"></div>
    <div id="hint"></div>
    <div id="timer"></div>
    <div id="message" class="message" style="display:none;"></div>
    <div class="answerContainer" id="answerContainer"></div>
    <div class="shuffleContainer" id="shuffleContainer"></div>
    <div class="controls">
        <button class="btn btn-secondary" id="resetBtn" style="display:none;">üîÑ L√†m l·∫°i level</button>
    </div>
    <button id="rewardBtn">üéÅ Nh·∫≠n Ph·∫ßn Th∆∞·ªüng</button>
</div>

<script>
const levels = [
    { code: 'HALLOWEEN', hint: 'üéÉ T√™n c·ªßa l·ªÖ h·ªôi kinh d·ªã v√†o ng√†y 31/10' },
    { code: 'SHOPPNGUYENROBLOX', hint: 'ƒê√¢y l√† bi·ªÉu t∆∞·ª£ng Shop c·ªßa ch√∫ng toii' },
    { code: 'PNGUYENROBLOXCHUCMUNGNGAYHALLOWEEN', hint: 'ƒê√¢y l√† t√™n shop - l·ªùi ch√∫c t·ªõi l·ªÖ h·ªôi' },
    { code: 'DICHVUROBLOXUYTIN-GIARE', hint: 'D·ªãch v·ª•....gi√° r·∫ª üòÆ' },
    { code: 'SUKIENEVENTHALLOWEENGIAITHUONGTU1K-500K', hint: 'M·ªü ƒë·∫ßu b·∫±ng t·ª´ S·ª± ki·ªán Event v√† kh√∫c cu·ªëi l√† gi·∫£i th∆∞·ªüng =00' }
];

let currentLevel = 0;
let timeLeft = 600;
let dragged = null;
let timerInterval = null;
const API_BASE = 'https://pnguyenroblox.onrender.com/api/halloween';

// Elements
const progressFill = document.getElementById('progressFill');
const levelInfo = document.getElementById('levelInfo');
const hintEl = document.getElementById('hint');
const answerContainer = document.getElementById('answerContainer');
const shuffleContainer = document.getElementById('shuffleContainer');
const timerEl = document.getElementById('timer');
const messageEl = document.getElementById('message');
const rewardBtn = document.getElementById('rewardBtn');
const resetBtn = document.getElementById('resetBtn');

// Utility functions
function shuffleString(str) { 
    return str.split('').sort(() => Math.random() - 0.5).join(''); 
}

function showMessage(text, type = 'info') {
    messageEl.textContent = text;
    messageEl.className = `message ${type}`;
    messageEl.style.display = 'block';
    setTimeout(() => {
        messageEl.style.display = 'none';
    }, 3000);
}

function updateProgress() {
    const progress = (currentLevel / levels.length) * 100;
    progressFill.style.width = progress + '%';
    levelInfo.textContent = `Level ${currentLevel + 1} / ${levels.length}`;
}

function renderLevel() {
    if (currentLevel >= levels.length) {
        completeGame();
        return;
    }

    const level = levels[currentLevel];
    hintEl.textContent = level.hint;
    updateProgress();

    // Render answer slots
    answerContainer.innerHTML = '';
    for (let i = 0; i < level.code.length; i++) {
        const slot = document.createElement('div');
        slot.className = 'answerSlot';
        slot.dataset.index = i;
        answerContainer.appendChild(slot);
    }

    // Render shuffled characters
    shuffleContainer.innerHTML = '';
    let shuffled = shuffleString(level.code);
    shuffled.split('').forEach(ch => {
        const div = document.createElement('div');
        div.className = 'shuffleChar';
        div.textContent = ch;
        div.draggable = true;
        div.addEventListener('dragstart', e => { 
            dragged = e.target;
            e.target.style.opacity = '0.5';
        });
        div.addEventListener('dragend', e => {
            e.target.style.opacity = '1';
        });
        shuffleContainer.appendChild(div);
    });

    resetBtn.style.display = 'inline-block';
}

// Drag and drop handlers
answerContainer.addEventListener('dragover', e => {
    e.preventDefault();
    const target = e.target.closest('.answerSlot');
    if (target) {
        target.classList.add('dragover');
    }
});

answerContainer.addEventListener('dragleave', e => {
    const target = e.target.closest('.answerSlot');
    if (target) {
        target.classList.remove('dragover');
    }
});

answerContainer.addEventListener('drop', e => {
    e.preventDefault();
    if (!dragged) return;
    
    const target = e.target.closest('.answerSlot');
    if (!target) return;
    
    target.classList.remove('dragover');
    
    // Return old character to shuffle area
    if (target.textContent) {
        const oldChar = document.createElement('div');
        oldChar.className = 'shuffleChar';
        oldChar.textContent = target.textContent;
        oldChar.draggable = true;
        oldChar.addEventListener('dragstart', e => { 
            dragged = e.target;
            e.target.style.opacity = '0.5';
        });
        oldChar.addEventListener('dragend', e => {
            e.target.style.opacity = '1';
        });
        shuffleContainer.appendChild(oldChar);
    }
    
    target.textContent = dragged.textContent;
    target.classList.add('filled');
    dragged.remove();
    dragged = null;
    
    checkLevelComplete();
});

async function checkLevelComplete() {
    const slots = answerContainer.querySelectorAll('.answerSlot');
    const levelCode = levels[currentLevel].code.split('');
    let correct = true;
    
    for (let i = 0; i < slots.length; i++) {
        if (slots[i].textContent !== levelCode[i]) {
            correct = false;
            break;
        }
    }
    
    if (correct) {
        showMessage('üéâ Ch√≠nh x√°c! Ti·∫øn sang level ti·∫øp theo...', 'success');
        
        // Save progress to backend
        try {
            const token = localStorage.getItem('token');
            if (token) {
                await fetch(`${API_BASE}/complete-level`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ level: currentLevel + 1 })
                });
            }
        } catch (e) {
            console.error('Error saving progress:', e);
        }
        
        setTimeout(() => {
            currentLevel++;
            renderLevel();
        }, 1500);
    }
}

function completeGame() {
    hintEl.textContent = 'üéä Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c level!';
    answerContainer.innerHTML = '';
    shuffleContainer.innerHTML = '';
    rewardBtn.style.display = 'block';
    resetBtn.style.display = 'none';
    progressFill.style.width = '100%';
    levelInfo.textContent = 'Ho√†n th√†nh!';
    if (timerInterval) {
        clearInterval(timerInterval);
    }
}

// Timer
function startTimer() {
    timerInterval = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            timerEl.textContent = '‚è∞ H·∫øt th·ªùi gian!';
            showMessage('Th·ªùi gian ƒë√£ h·∫øt! Vui l√≤ng l√†m l·∫°i.', 'error');
            answerContainer.querySelectorAll('.answerSlot').forEach(s => {
                s.textContent = '';
                s.classList.remove('filled');
            });
            shuffleContainer.innerHTML = '';
            return;
        }
        
        let min = Math.floor(timeLeft / 60);
        let sec = timeLeft % 60;
        timerEl.textContent = `‚è±Ô∏è Th·ªùi gian: ${min}:${sec < 10 ? '0' + sec : sec}`;
        timeLeft--;
    }, 1000);
}

// Reset level
resetBtn.addEventListener('click', () => {
    renderLevel();
    showMessage('ƒê√£ l√†m m·ªõi level hi·ªán t·∫°i', 'info');
});

// Reward button
rewardBtn.addEventListener('click', async () => {
    const token = localStorage.getItem('token');
    if (!token) {
        showMessage('‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ nh·∫≠n th∆∞·ªüng', 'error');
        return;
    }

    rewardBtn.disabled = true;
    showMessage('ƒêang x·ª≠ l√Ω...', 'info');

    try {
        const res = await fetch(`${API_BASE}/reward`, {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
        });
        const data = await res.json();
        
        if (data.success) {
            showMessage(`üéâ Ho√†n th√†nh! B·∫°n nh·∫≠n ƒë∆∞·ª£c ${data.amount.toLocaleString()}ƒë`, 'success');
            rewardBtn.textContent = '‚úÖ ƒê√£ nh·∫≠n th∆∞·ªüng';
        } else {
            showMessage(`‚ùå ${data.error}`, 'error');
            rewardBtn.disabled = false;
        }
    } catch (e) {
        console.error(e);
        showMessage('‚ùå L·ªói k·∫øt n·ªëi server', 'error');
        rewardBtn.disabled = false;
    }
});

// Initialize game
async function initGame() {
    const token = localStorage.getItem('token');
    
    if (!token) {
        showMessage('‚ö†Ô∏è Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ ch∆°i', 'error');
        return;
    }

    try {
        const res = await fetch(`${API_BASE}/status`, {
            headers: { 'Authorization': 'Bearer ' + token }
        });
        const data = await res.json();
        
        if (data.rewardClaimed) {
            hintEl.textContent = '‚úÖ B·∫°n ƒë√£ ho√†n th√†nh v√† nh·∫≠n th∆∞·ªüng r·ªìi!';
            answerContainer.innerHTML = '';
            shuffleContainer.innerHTML = '';
            progressFill.style.width = '100%';
            levelInfo.textContent = 'ƒê√£ ho√†n th√†nh';
            timerEl.textContent = 'üéâ C·∫£m ∆°n b·∫°n ƒë√£ tham gia!';
            return;
        }
        
        if (data.completed) {
            currentLevel = levels.length;
            completeGame();
            return;
        }
        
        if (data.level > 0) {
            currentLevel = data.level;
            showMessage(`Ti·∫øp t·ª•c t·ª´ level ${currentLevel + 1}`, 'info');
        }
        
        renderLevel();
        startTimer();
    } catch (e) {
        console.error(e);
        showMessage('‚ùå L·ªói k·∫øt n·ªëi server. Ch∆°i ·ªü ch·∫ø ƒë·ªô offline.', 'error');
        renderLevel();
        startTimer();
    }
}

// Start game
initGame();
</script>

</body>
</html>